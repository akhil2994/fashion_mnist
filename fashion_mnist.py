# -*- coding: utf-8 -*-
"""Fashion_MNIST

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u51ZHmi-8MhLWkq9B5hWeaLHE-d1hpkR
"""

import torch
import torchvision
from torch import nn, optim
import torch.nn.functional as F
from torchvision import datasets, transforms
import numpy as np
from sklearn.metrics import accuracy_score

"""**Import necessary libraries and define a simple linear classifier with nn.Module**"""

class Pytorch_Classify(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(784, 256)
        self.fc2 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, 64)
        self.fc4 = nn.Linear(64, 10)
        
    def forward(self, x):
        # make sure input tensor is flattened
        x = x.view(x.shape[0], -1)	
        
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = F.relu(self.fc3(x))
        x = F.log_softmax(self.fc4(x), dim=1)
        
        return x

"""**Load the training and test dataset, perform the training and save the model**"""

#normalize the data
transform = transforms.Compose([transforms.ToTensor(),
                                transforms.Normalize([0.5], [0.5]),
                              ])

#training data
trainset = torchvision.datasets.FashionMNIST("./data", download=True, transform=
                                                transforms.Compose([transforms.ToTensor()]))

trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)

#model, loss function and optimizer
model = Pytorch_Classify()
criterion = nn.NLLLoss()
optimizer = optim.SGD(model.parameters(), lr=0.1)

#training
epochs = 10
model.train()
for e in range(epochs):
    train_loss = 0
    for images, labels in trainloader:
        images = images.view(images.shape[0], -1)
        
        optimizer.zero_grad()
        output = model.forward(images)
        loss = criterion(output, labels)
        loss.backward()
        optimizer.step()
        
        train_loss += loss.item()
    else:
        print(f"Training loss: {train_loss/len(trainloader)}")

test_set = torchvision.datasets.FashionMNIST("./data", download=True, train=False, transform=
                                               transforms.Compose([transforms.ToTensor()]))

testloader = torch.utils.data.DataLoader(test_set, batch_size=64, shuffle=True)

"""**Test for accuracy of the model**"""

#evaluate and test for accuracy
model.eval()

y_preds = np.empty((1))
y_test = np.empty((1))
for images, labels in testloader:
    with torch.no_grad():
        images = images.view(images.shape[0], -1)
        output = model.forward(images)
        y_test = np.concatenate([y_test,labels.numpy()], axis=0)
        _, top_class = output.topk(1, dim=1)
        y_preds = np.concatenate([y_preds,np.squeeze(top_class.numpy())], axis=0)

y_test = y_test.astype(int)
y_preds = y_preds.astype(int)
accuracy_score(y_test, y_preds)

#save model
torch.save(model.state_dict(), '/content/drive/My Drive/Adagrad/pytorch_fmnist.pth')

#convert to torch script
test_image, test_label = next(iter(trainloader))

#store tracing model (for CPP) with converted script
traced_script_module = torch.jit.trace(model, test_image)
traced_script_module.save("/content/drive/My Drive/Adagrad/converted_pytorch_fmnist.pt")



"""###**Visualisation of data in Fashion MNIST**###"""

